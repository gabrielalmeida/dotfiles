set nocompatible
set sh=/bin/bash
set backupdir=~/.vim_backup/
set directory=~/.vim_swp/
set ruler
set number
set laststatus=2
set incsearch
set showcmd
set autoindent
set expandtab
set tabstop=2
set shiftwidth=2
set numberwidth=5
set textwidth=80
set ignorecase
set smartcase
set tags=./tags;
set guioptions-=T
set guioptions-=r
set foldenable
set foldmethod=manual
set mouse=a
set colorcolumn=80
set backspace=indent,eol,start
set nowrap
set lazyredraw
set ttyfast

" Store temporary files in a central spot
" Check issue vim-obsession#18
let vimtmp = $HOME . '/.tmp/' . getpid()
silent! call mkdir(vimtmp, "p", 0700)
let &backupdir=vimtmp
let &directory=vimtmp

"Maintain undo forever, even after a restart
"tell it to use an undo file
set undofile

"set a directory to store the undo history(create this dir manually before)
set undodir=~/.vimundo/

set encoding=utf-8  " The encoding displayed.
set fileencoding=utf-8  " The encoding written to file.

set completeopt=longest,menu
set wildmode=list:longest,list:full
set complete=.,t

" If we are on OS X, NERDTree Arrows don't work well, so disable them
let g:NERDTreeDirArrows=1
let g:NERDTreeHijackNetrw=1

" Note: Skip initialization for vim-tiny or vim-small.
  if !1 | finish | endif

if has('vim_starting')
   if &compatible
     set nocompatible               " Be iMproved
   endif

   " Required:
   set runtimepath+=~/.vim/bundle/neobundle.vim/
 endif


 " Required:
 call neobundle#begin(expand('~/.vim/bundle/'))

 " Let NeoBundle manage NeoBundle
 " Required:
 NeoBundleFetch 'Shougo/neobundle.vim'


" My bundles
NeoBundle 'Shougo/vimproc', {
      \ 'build' : {
      \     'windows' : 'make -f make_mingw32.mak',
      \     'cygwin' : 'make -f make_cygwin.mak',
      \     'mac' : 'make -f make_mac.mak',
      \     'unix' : 'make -f make_unix.mak',
      \    },
      \ }

" Essentials
NeoBundle "scrooloose/nerdcommenter"
NeoBundle "tomtom/tlib_vim"
NeoBundle "MarcWeber/vim-addon-mw-utils"
NeoBundle "bling/vim-airline"
NeoBundle "flazz/vim-colorschemes"
NeoBundle "tpope/vim-sensible"
NeoBundle "tpope/vim-obsession"
NeoBundle "tpope/vim-fugitive"
NeoBundle "tpope/vim-git"
NeoBundle "tpope/vim-surround"
NeoBundle "Shougo/unite.vim"
NeoBundle "Shougo/neomru.vim"
NeoBundle "marijnh/tern_for_vim"
" NeoBundle "Shougo/vimshell.vim"

" Nerdtree
NeoBundle "scrooloose/nerdtree"
NeoBundle 'Xuyuanp/nerdtree-git-plugin'

" Unimpaired
NeoBundle "tpope/vim-unimpaired"

" Vertical Movement
" NeoBundle "bruno-/vim-vertical-move"
" NeoBundle "coderifous/textobj-word-column.vim"

" Misc
" NeoBundle "xolox/vim-misc"

" Tags
" NeoBundle "majutsushi/tagbar"
" NeoBundle "xolox/vim-easytags"

" Live markdown preview
NeoBundle "suan/vim-instant-markdown"

" Procession
" Allow vim-obsession to work automatically
NeoBundle 'dhruvasagar/vim-prosession', {'depends': 'tpope/vim-obsession'}

" Indexed-Search
NeoBundle "henrik/vim-indexed-search"

" IndentLine
NeoBundle "Yggdroot/indentLine"
let g:indentLine_color_term = 110 
let g:indentLine_color_gui = '#A4E57E'
let g:indentLine_color_tty_light = 1
let g:indentLine_color_tty_dark = 1
let g:indentLine_char = 'â”†'

" Snips/Completation
 let g:EclimCompletionMethod = 'omnifunc' " Eclim for JAVA

NeoBundle "ervandew/supertab"
NeoBundle "Shougo/neocomplete"
NeoBundle "SirVer/ultisnips"
NeoBundle "honza/vim-snippets"

" Disable AutoComplPop.
let g:acp_enableAtStartup = 0
" Use neocomplete.
let g:neocomplete#enable_at_startup = 1
" Use smartcase.
let g:neocomplete#enable_smart_case = 1
" Set minimum syntax keyword length.
let g:neocomplete#sources#syntax#min_keyword_length = 3
let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'

" Define dictionary.
let g:neocomplete#sources#dictionary#dictionaries = {
    \ 'default' : '',
    \ 'vimshell' : $HOME.'/.vimshell_hist',
    \ 'scheme' : $HOME.'/.gosh_completions'
        \ }

" Define keyword.
if !exists('g:neocomplete#keyword_patterns')
    let g:neocomplete#keyword_patterns = {}
endif
let g:neocomplete#keyword_patterns['default'] = '\h\w*'

" Plugin key-mappings.
inoremap <expr><C-g>     neocomplete#undo_completion()
inoremap <expr><C-l>     neocomplete#complete_common_string()

" Recommended key-mappings.
" <CR>: close popup and save indent.
inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
function! s:my_cr_function()
  return neocomplete#close_popup() . "\<CR>"
  " For no inserting <CR> key.
  "return pumvisible() ? neocomplete#close_popup() : "\<CR>"
endfunction
" <TAB>: completion.
inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
" <C-h>, <BS>: close popup and delete backword char.
inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
inoremap <expr><C-y>  neocomplete#close_popup()
inoremap <expr><C-e>  neocomplete#cancel_popup()

" Enable omni completion.
autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

" Enable heavy omni completion.
if !exists('g:neocomplete#sources#omni#input_patterns')
  let g:neocomplete#sources#omni#input_patterns = {}
endif
let g:neocomplete#sources#omni#input_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
let g:neocomplete#sources#omni#input_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
let g:neocomplete#sources#omni#input_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'

" For perlomni.vim setting.
" https://github.com/c9s/perlomni.vim
" let g:neocomplete#sources#omni#input_patterns.perl = '\h\w*->\h\w*\|\h\w*::'

" UltiSnips configs
let g:UltiSnipsExpandTrigger="<tab>"
let g:UltiSnipsJumpForwardTrigger="<c-b>"
let g:UltiSnipsJumpBackwardTrigger="<c-z>"

" Make it colorful
NeoBundle "Rykka/colorv.vim"
NeoBundle "lilydjwg/colorizer"

" Javascript
NeoBundle "pangloss/vim-javascript"

" Less/Stylus
NeoBundle "groenewege/vim-less"
NeoBundle "wavded/vim-stylus.git"

" CoffeeScript 
NeoBundle "kchmck/vim-coffee-script"

" Jade
NeoBundle "digitaltoad/vim-jade"
" Load jade syntax
au BufNewFile,BufRead,BufReadPost *.jade.html set filetype=jade

" Twig
NeoBundle "evidens/vim-twig"

" Symfony
NeoBundle "docteurklein/vim-symfony"

" Meteor
NeoBundle "cmather/vim-meteor-snippets"

" React
NeoBundle "justinj/vim-react-snippets"
NeoBundle "mxw/vim-jsx"

" HTML5
NeoBundle 'othree/html5.vim'

" Emmet 
NeoBundle "mattn/emmet-vim"

" Dash.app 
NeoBundle "rizzatti/dash.vim"

" FZF
NeoBundle "junegunn/fzf"

" PHP/Laravel things
NeoBundle "xsbeats/vim-blade.git" " Laravel blade templating engine
NeoBundle "StanAngeloff/php.vim"
"NeoBundle "m2mdas/phpcomplete-extended"
"NeoBundle "m2mdas/phpcomplete-extended-laravel"

" Better JSON
NeoBundle "elzr/vim-json"

" Syntastic
NeoBundle "scrooloose/syntastic"

" Editor Config
NeoBundle "editorconfig/editorconfig-vim"

" JS-Beautify
NeoBundle "einars/js-beautify"
NeoBundle "maksimr/vim-jsbeautify"

" Lolololo loremipsum!!
NeoBundle "vim-scripts/loremipsum"

call neobundle#end()

" Required by neobundle
filetype plugin indent on

" Lets check for new things to be installed!
NeoBundleCheck

" Colorize my colors here vim pl0x
let g:colorv_preview_ftype='css,php,html,js,coffee,sass,scss,less,styl,svg'


" Colorscheme
" I like:
" Dark: molokai, jellybeans, mustang, badwolf, vividchalk, wombat, railscast,
" lucario
" Light: solarized, github, summerfruit256
colorscheme summerfruit256 
set background=light
syntax on
"highlight ColorColumn ctermbg=white

if (&t_Co > 2 || has("gui_running")) && !exists("syntax_on")
  syntax on
endif

"if has("autocmd")
  "filetype plugin indent on

  "autocmd BufNewFile,BufRead *.txt setfiletype text

  "autocmd FileType text,markdown,html,xhtml,eruby setlocal wrap linebreak nolist

  "au FocusLost * :set number
  "au InsertEnter * :set number

  "augroup vimrcEx
    "au!

    "autocmd BufReadPost *
          "\ if line("'\"") > 0 && line("'\"") <= line("$") |
          "\   exe "normal g`\"" |
          "\ endif

    "" Automatically load .vimrc source when saved
    "autocmd BufWritePost .vimrc source $MYVIMRC

  "augroup END

"else
  "set autoindent
"endif " has("autocmd")

" automatically open quickfix window on grep searches
"autocmd QuickFixCmdPost *grep* cwindow

"if has("gui_running")
  "set guifont=Menlo\ Regular:h14
"endif

" Functions
"function! NumberToggle()
  "if(&relativenumber == 1)
    "set number
  "else
    "set relativenumber
  "endif
"endfunc

" Key Bindings
let mapleader = ","

inoremap kj <Esc>
inoremap <C-c> <Esc>
"nnoremap <Leader>n :call NumberToggle()<cr>

" Is this for autocomplete?
"imap <Tab> <C-N>

" Split windows
nnoremap <Leader>h :sp<cr><C-w><C-w>
nnoremap <Leader>v :vsp<cr><C-w><C-w>

" Fugitive bindings
nnoremap <Leader>s :Gstatus<cr>

" Easily switch between windows
nnoremap <silent> <c-k> :wincmd k<cr>
nnoremap <silent> <c-j> :wincmd j<cr>
nnoremap <silent> <c-h> :wincmd h<cr>
nnoremap <silent> <c-l> :wincmd l<cr>

" VimShell
" nnoremap <Leader>c :VimShell<cr> 

" Exit insert mode and write file
inoremap <leader>w <Esc> :w<cr>
nnoremap <leader>w :w<cr>

" Opens split explorer inside current pane
nnoremap <leader><Tab> :e.<cr>

" Opens split explorer inside current pane on same dir of current file
nnoremap <leader>` :e %:p:h<cr>

" NERDTreeToggle
nnoremap <leader>p :NERDTreeToggle<cr>

" NERDCommenter
map <leader>m  <plug>NERDCommenterToggle

" Syntastic
set statusline+=%#warningmsg#
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%*

let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 0

nnoremap <leader>E :SyntasticToggleMode<cr>

let g:syntastic_javascript_checkers = ['eslint']

" js-beautify
map <c-f> :call JsBeautify()<cr>
" or
autocmd FileType javascript noremap <buffer>  <c-f> :call JsBeautify()<cr>
" for html
autocmd FileType html noremap <buffer> <c-f> :call HtmlBeautify()<cr>
" for css or scss
autocmd FileType css noremap <buffer> <c-f> :call CSSBeautify()<cr>


" Unite
let g:unite_source_history_yank_enable=1

" Start in insert mode
"let g:unite_enable_start_insert = 1

" Open in bottom right
let g:unite_split_rule = "botright"

let g:unite_enable_split_vertically = 1

" Shorten the default update date of 500ms
let g:unite_update_time = 500

let g:unite_source_file_mru_limit = 300
let g:unite_cursor_line_highlight = 'TabLineSel'

let g:unite_source_file_mru_filename_format = ':~:.'
let g:unite_source_file_mru_time_format = ''

let g:unite_source_grep_max_candidates = 200

" Change file_rec/async command
if executable('ag')
  " Use ag in unite grep source.
  let g:unite_source_rec_async_command = 'ag --follow --nocolor --nogroup --hidden ' .
        \ '--ignore ''.hg'' --ignore ''.svn'' --ignore ''.git'' --ignore ''.bzr'' ' .
        \ '--ignore ''**/*.pyc'' -g ""'
  let g:unite_source_grep_command = 'ag'
elseif executable('ack-grep')
  let g:unite_source_grep_command = 'ack-grep'
  " Match whole word only. This might/might not be a good idea
  let g:unite_source_grep_default_opts = '--no-heading --no-color -a -H'
  "let g:unite_source_grep_default_opts = '--no-heading --no-color -a -w'
  let g:unite_source_grep_default_opts .= '--exclude ''\.(git|svn|hg|bzr)'''
  let g:unite_source_grep_recursive_opt = ''
elseif executable('ack')
  let g:unite_source_grep_command = 'ack'
  let g:unite_source_grep_default_opts = '--no-heading --no-color -a -w'
  let g:unite_source_grep_default_opts .= '--exclude ''\.(git|svn|hg|bzr)'''
  let g:unite_source_grep_recursive_opt = ''
endif

call unite#filters#matcher_default#use(['matcher_fuzzy'])

" Use file_rec/git option instead of async if it's too lazy
nnoremap <Leader>t :Unite -start-insert -no-empty 
  \ -resume -buffer-name=files buffer file_rec/async:!<cr>
" \ -buffer-name=files buffer file_rec/git<CR>

nnoremap <Leader>f :Unite -buffer-name=files -start-insert file<cr>
nnoremap <Leader>r :Unite -buffer-name=mru -start-insert file_mru<cr>
nnoremap <Leader>g :Unite -buffer-name=register -start-insert register<cr>
nnoremap <Leader>o :Unite -buffer-name=outline -start-insert outline<cr>
nnoremap <Leader>y :Unite -buffer-name=yank history/yank<cr>
nnoremap <Leader>e :Unite -buffer-name=buffer buffer<cr>

call unite#custom_source('file,file_rec,file_rec/async,grep',
      \ 'ignore_pattern', join([
      \ '\.git/',
      \ '\.bundle/',
      \ '\.rubygems/',
      \ '\.meteor/',
      \ 'vendor/',
      \ ], '\|'))
